# 現場で役立つシステム設計の原則　1～3章
# ソフトウェアの変更が大変になる理由
## 設計に問題があるから
### 設計・・・ソフトウェア全体をすっきりした形に整えること

設計のアウトプットはソースコード。ソースコードを整理整頓して、どこに何が書いてあるか分かりやすくする。

設計の善し悪しの判断はプログラムの変更をするときに出る。良い設計で作られているならば、↑の悩みは発生しない。

# 変更が大変なプログラムの特徴
- メソッドが長い
- クラスが大きい
- 引数が多い

これらは最初から肥大化していたわけではない。ちょっとした修正が必要になった時、ちょっとしたバリエーションがほしくなった時に追加された部分が少しずつ大きくなっている。

変更するたびに変更が大変になる負のスパイラル。

# プログラムの変更が楽になる書き方
## 分かりやすい名前を使う
### 変数の命名の仕方
- 1文字の変数（意味のない変数）
```
int $a;
int $b;
return $a * $b;
```
- 省略した変数
```
int $qty;
int $up;
return $qty * $up;
```
- 意味のある単語を使った変数
```
int $quantity;
int $unitPrice;
return $quantity * $unitPrice;
```
## 長いメソッドは「段落」に分けて読みやすくする
- 切れ目がはっきりしないコード
```
int $price = $quantity * $unitPrice;
if ($price < 3000) {
    $price += 500; //送料
}
$price = $price * taxRate();
```
- 3つの段落に分けたコード
```
int $price = $quantity * $unitPrice;

if ($price < 3000) {
    $price += 500; //送料
}

$price = $price * taxRate();
```

## 目的ごとに変数を用意する

例）ローカル変数$priceを使いまわすと、変更時に思わぬ場所に変更が生じる可能性がある。影響範囲を狭めるために、目的ごとに別々のローカル変数を適宜定義していく。
```
int $basePrice = $quantity * $unitPrice;

int $shippingCost = 0; //総量の初期値
if ($basePrice < 3000) {
    $shippingCost = 500; //送料500円
}
int $itemPrice = ($basePrice + $shippingCost) * taxRate();
```
これを行うと段落ごとの結びつきが弱くなる。リファクタリングの基本テクニックである。

## メソッドとして独立させる

- 詳細をメソッドに移動するため、元のコードがシンプルになり読みやすくなる
- メソッドの名前からコードの意図を理解しやすくなる
- メソッド内に変更の影響を閉じ込めやすくなる


## 異なるクラスの重複したコードを無くす
1つのクラスの中であれば、メソッドに抽出するだけで重複したコードを無くせる。  
しかし、異なるクラスにロジックが重複している場合はどうする？

- それぞれのクラスで該当する部分をメソッドに抽出する
- 2つのクラスに参照関係があるなら、参照する側で参照先のオブジェクトからメソッドを呼び出すようにする。2つのクラスに参照関係がない場合はクラスを新たに作成し、元のクラスから抽出したメソッドを移動する。
- 元の2つのメソッド呼び出しを、それぞれ新しいクラスの共通メソッドを利用するように書き換える。

## 狭い関心事に特化したクラスにする
### ドメインオブジェクト・・・業務で扱われる用語に合わせて、その用語の関心ごとに対応するクラス

- 業務の用語と直接対応するドメインオブジェクトを用意することが、業務アプリケーションの変更を容易にするオブジェクト指向らしい設計のアプローチ

- 業務を理解するために要求を分析し、そこで発見した業務の関心ごとの単位を、そのままプログラミング単位としてクラスで表現するのが、オブジェクト指向開発のやり方。

## メソッドは短く、クラスは小さく
### 変更を楽で安全にする
- メソッド名やクラス名が変更の対象箇所を特定する手がかりになる
- コードの重複がなくなり、修正箇所が1カ所になる
- コード変更の影響を、メソッドやクラスに閉じ込めやすい

たった数行の処理でも、それが複数のクラスで重複するようであれば積極的に別クラスに抽出する。
たとえ1行の処理でも、メソッドとして独立させることで見通しが良くなることが往々にしてある。

## 変更に苦しむのは、いつでも長いメソッドと大きなクラス。
## 「メソッドの抽出」と「クラスの抽出」によって、コードを「短いメソッド」と「小さなクラス」に小分けして整理するのが、変更を楽にする設計の基本である

# 小さなクラスで分かりやすく安全に
## データとロジック
### 業務アプリケーションの基本データ
- 数値・・・金額、数量
- 日付・・・予定日、注文日、有効期限、問合せ日
- 文字・・・氏名、電話番号、説明  
業務アプリケーションはこのような基本データ型とそれを使った判断/加工/計算のロジックを最小単位として、組み合わせたもの
## 基本データ型の落とし穴
業務の意図を考慮出来ているか？
```
// 数量
int $quantity;
```
intの範囲は大体-20億～20億の整数
この範囲は行からみて正常か？
業務の関心ごとからかけ離れた異常な値を扱うことにならないか？

### 値の範囲を宣言してプログラムを分かりやすく安全にする
業務アプリケーションで数量を扱うとき、intのすべての範囲が必要になることはない。値の範囲はもっと詳細に定義するべき。
業務的に正しい値を扱うために、Quantityクラスを独自に宣言して異常な値を扱わないようにする。
```
// クラス変数に異常な値を指定できてしまう

$quantity = new Quantity();
$quantity->quantity = 999999999999;


class Quantity
{
    public int $quantity;
}

```
そこで下記のようにする
```
$quantity = new Quantity();
$quantity->setQuantity(10);

class Quantity
{
    // privateにして外部から直接値をセットできないようにする
    private int $quantity;

    public function setQuantity(int $quantity)
    {
        // 適性値かどうかの判定も行うセッターを用意
        // 扱う値の範囲は別の場所で定数化したほうがよさそう。
        // クラスごとに扱う値の適性値判定メソッド(isCollect, isRightなど)の実装を強制させるために、インターフェースを使うのもよさそう。
        if ($quantity <= 200) {
            $this->quantity = $quantity;
        } else {
            throw Exception;
        }
    }

    // 他メソッド...
    public function getQuantity()
    {
        return $this->quantity;
    }

}
```

関心ごとのクラス自体が値の制限を行うことで、数値計算が安全で確実になる。
文字情報、日付等も同じ。

電話番号の変数$telをString型で宣言したら次の意味になる。
```
・文字種はなんでもいい
・長さは無制限
・形式は自由
```
だが実際には電話番号には次のルールがある。
```
・文字種は数字だけ
・市外局番は0から始まる
・合計の桁数は10桁
・形式は、"市外局番-市内局番-加入者番号"
・加入者番号は4桁固定
などなど
```
#### 電話番号をString型で扱うと、実際にこのようなデータが混入する可能性があり、バグの可能性を孕んでいる。

#### 業務のルールや必要に合わせて、上記の制約をもとにきちんと値を制限するのが業務アプリケーションとしてあるべき姿。この場合も、String型として宣言するのではなく、新たにTelephoneクラスを作成し、電話番号をTelephone型として扱うことで、正しいデータであることを保証したうえで業務アプリケーション内で使うようにするべき。
#### 実際にその業務をしている側の視点で見ても、数量は単なるintではないし、電話番号も単なるStringではない。

## 値を扱うための専用クラスを作る
業務アプリケーションをオブジェクト指向で設計する場合には、業務で扱うデータの種類ごとの専用のクラス「値オブジェクト」を使う。
### よく使う値オブジェクト
#### 数値系
- Quantity
- Unit
- Amount
- Money
- Currency
#### 日付系
- Days
- Hours
- Period
- DueDate
- DateOfRecord
- DateOfOccurance
- YearAndMonth
#### 文字列系
- Telephone
- Email
- Url
- Line
- Description
- Note
- Definition

### 値オブジェクトは業務の用語そのもの
- 業務で扱う情報の名前
- 業務上の判断や計算に使う用語
#### 業務の用語をそのままクラスやメソッド名として使うと、プログラムが業務の説明書のようになる

#### クラス名をメソッドの引数の型指定などで積極的に使うことで、ロジックの処理でバグが発生する可能性を減らせる

## コレクション型を扱うロジックを専用クラスに閉じ込める
### 更に複雑なロジックに対応するため、コレクション型のデータとそれに関連するロジックを1つのクラスに集める

#### 値オブジェクト、またはエンティティのコレクションクラスを作成するとき、クラスの意図を明確にしコードを簡潔に保つために、クラス変数はコレクションのみ（コレクションオブジェクト、またはファーストクラスコレクションという）とするのが望ましい。

## 3層＋ドメインモデルの構造
- プレゼンテーション層  
└UIなどと外部の入出力を受け持つ
- アプリケーション層  
└業務機能のマクロな手順の記述
- データソース層  
└データベースとの入出力を受け持つ  

における業務上の判断/加工/計算のロジックは全てドメインオブジェクトに任せる（超複雑だったりするときは他のクラスに任せるけど・・・）  

ドメインモデルでは、画面やデータベースに依存せず、常に業務の観点から業務ロジックを整理できるので明確。

業務ロジックの複雑さをドメインモデルとして分離して整理する。

# データモデルとドメインモデル
### データモデル・・・データをどのように整理して設計するかが肝（データとロジックは分離している）

## データクラスの問題点
#### 見通しが悪い
- コードの重複が起きやすい  
└クラスを参照している場所であれば、どこでもロジックを書けるため。
- アプリケーションの構造が画面の構造に依存する  
└画面と機能クラスを1対1で関連付ける設計が割と一般的だが、同じドメインモデルを扱う機能で、重複した処理が発生しやすい。

- データベースの都合に影響される  
└テーブルのCRUD単位に設計することが割と一般的。しかし、CRUD操作で用いる値を導出するロジックをどこに置くべきか明確ではない。テーブルを参照するクラスではどこでもロジックを記述できてしまう。

### ドメインモデル・・・データと業務ロジックをクラス単位でどのように整理して設計するかが肝（データとロジックが一体化している）
データモデルとは違い、業務の関心ごとである業務クラスが持つドメインオブジェクトのメソッドを使って欲しいデータを取得する。  

例）ドメインオブジェクト　Userクラス関連
```
// ドメインオブジェクト：User（エンティティ）
// User,Proposal(案件),detail(明細)など同一性（一意のIDなど）によって区別されるものをDDDではエンティティという
Class User
{
    // ドメインオブジェクト(値オブジェクト:同一性の概念が無い点がエンティティと異なる)
    // 基本的に業務モデルは下記のような値オブジェクトの集合で表される。
    ID $id;
    Name $name; // Nameクラスのインスタンス変数$name（インスタンス変数String $firstName, String $lastNameと、名前に関わるルール、メソッドを持つ）
    Age $age; // この領域の関心ごとが生年月日ではなく年齢のときは、新たに年齢クラスをつくってこちらを優先的に使うようにする。
    Telephone $telephone; // こちらも同様
}

// ドメインオブジェクト：Name // 業務で扱う名前に関する値、ルール、メソッドを持つ
Class Name
{
    String $firstName;
    String $lastName;

    function セッター() {
        // セッターの処理
    }
    // フルネームを取得
    function fullName() {
        return $this->firstName . ' ' .$this->lastName;
    }
}

// ドメインオブジェクト：UserCollection // Userの集約を使いたいとき（何かの一覧表示など）はこちらを使う
Class UserCollection
{
    // 要素がUserインスタンスであることをたぶん指定するべき（勉強中）
    array $users = [];

    // Userの集約に関する業務ロジックは下記に記述
    // セッター（要素の型の条件はここかコンストラクタで指定できると思う）
    function setUsers($users) {
        $this->users = $users;
    }

    // 全部取得
    function all() {
        return $this->users;
    }
    // 男性のみ取得
    // function allOfMale() {
        return ......;
    }
    // 特定のカラムの値だけ取得
    // function column(String $column) {
        return ......;
    }
}
```



# ドメインモデルで設計するコツ
- メソッドをロジックの置き場にする  
└データクラスでの設計で重複が発生しやすいのは、データクラスが持っているデータをそのまま別のクラスに渡してしまうから。データを加工して渡すメソッドをたくさん作っておき、その代わり安易にgetterを書かないのがコツ。    
これにより  
・データを持つ側のクラスにロジックが増える  
・データをgetしていたクラスからロジックが減る  
・使う側のクラスは、データを使った計算結果を受け取るようになる。  
このように、データとメソッドを1つのクラスにまとめることで、影響範囲を限定して変更に強い設計にすることができる。

- 使う側のクラスに業務ロジックを書くのは非推奨。設計を見直そう  
└ データを持つクラスのメソッドを「ロジックの置き場」と考えれば、そのクラス自体が判断/加工/計算までやってくれる便利な部品になる。

- 利用者の関心ごととプログラミング単位を一致させる  
└ 業務に使っている用語をクラス名にする  
- 業務の分析をそのままクラス設計に反映させる  
└ ドメインモデルでは業務ロジックが中心  
例）ある業務の関心事に「年齢」があるとき、ドメインモデルでは年齢クラスを作る。（内部に生年月日というインスタンス変数を持ち、その値を使って年齢を計算するロジックを持つ）。年齢を知りたいという関心ごとがあり、それを計算するロジックの置き場所が必要だから年齢クラスを作る、というアプローチ。  
└ 一方、データモデルでは年齢は記録するデータではなく、ただの計算の結果という扱い。テーブルには計算のもとになる生年月日だけを記録するため、データ取得、データを渡す、そのデータを利用する側のクラスのメソッドの中で年齢が必要な時だけ年齢を求める処理をしている。



